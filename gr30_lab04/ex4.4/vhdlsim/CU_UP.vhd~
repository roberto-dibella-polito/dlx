library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
--use ieee.std_logic_arith.all;
use ieee.numeric_std.all;
use work.myTypes.all;

entity CU_UP is
  port (
    -- FIRST PIPE STAGE OUTPUTS
    EN1    : out std_logic;               -- enables the register file and the pipeline registers
    RF1    : out std_logic;               -- enables the read port 1 of the register file
    RF2    : out std_logic;               -- enables the read port 2 of the register file
    WF1    : out std_logic;               -- enables the write port of the register file
    -- SECOND PIPE STAGE OUTPUTS
    EN2    : out std_logic;               -- enables the pipe registers
    S1     : out std_logic;               -- input selection of the first multiplexer
    S2     : out std_logic;               -- input selection of the second multiplexer
    ALU1   : out std_logic;               -- alu control bit
    ALU2   : out std_logic;               -- alu control bit
    -- THIRD PIPE STAGE OUTPUTS
    EN3    : out std_logic;               -- enables the memory and the pipeline registers
    RM     : out std_logic;               -- enables the read-out of the memory
    WM     : out std_logic;               -- enables the write-in of the memory
    S3     : out std_logic;               -- input selection of the multiplexer
    -- INPUTS
    OPCODE : in  std_logic_vector(OP_CODE_SIZE - 1 downto 0);
    FUNC   : in  std_logic_vector(FUNC_SIZE - 1 downto 0);              
    Clk : in std_logic;
    Rst : in std_logic);                  -- Active Low
end CU_UP;

architecture STRUCTURE of CU_UP is
  
  --type mem_array is array (0 to MEM_SIZE-1) of std_logic_vector(4 downto 0);
  -- PROBLEM WITH INDEX
  type mem_array is array (integer range 0 to 63) of std_logic_vector(4 downto 0);
  type mux_out_array is array(0 to 2) of std_logic_vector(4 downto 0);
  
  -- MICROCODE MEMORY
  -- Each control word has been divided based on the stage they are used, as
  -- follow:
  --  ___________
  -- | OUT_ADDI1 | <- Address 0:  First stage output for ADDI1 command
  -- |           | <- Address 1:  Second stage output for ADDI1
  -- |___________| <- Address 2:  Third stage output for ADDI1
  -- | OUT_SUBI1 | <- Address 3:  First stage output for SUBI 1
  --
  -- ...And so on
  
  signal OUT_MEM: mem_array := ("00" & OUT_ADDI1(12 downto 10), -- Address 0
                                OUT_ADDI1(9 downto 5),
                                OUT_ADDI1(4 downto 0),
                                "00" & OUT_SUBI1(12 downto 10), -- Address 3
                                OUT_SUBI1(9 downto 5),
                                OUT_SUBI1(4 downto 0),
                                "00" & OUT_ANDI1(12 downto 10), -- Address 6
                                OUT_ANDI1(9 downto 5),
                                OUT_ANDI1(4 downto 0),
                                "00" & OUT_ORI1(12 downto 10),  -- Address 9
                                OUT_ORI1(9 downto 5),
                                OUT_ORI1(4 downto 0),
                                "00" & OUT_ADDI2(12 downto 10), -- Address 12
                                OUT_ADDI2(9 downto 5),
                                OUT_ADDI2(4 downto 0),
                                "00" & OUT_SUBI2(12 downto 10), -- Address 15
                                OUT_SUBI2(9 downto 5),
                                OUT_SUBI2(4 downto 0),
                                "00" & OUT_ANDI2(12 downto 10), -- Address 18
                                OUT_ANDI2(9 downto 5),
                                OUT_ANDI2(4 downto 0),
                                "00" & OUT_ORI2(12 downto 10),  -- Address 21
                                OUT_ORI2(9 downto 5),
                                OUT_ORI2(4 downto 0),
                                "00" & OUT_MOV(12 downto 10),   -- Address 24
                                OUT_MOV(9 downto 5),
                                OUT_MOV(4 downto 0),
                                "00" & OUT_S_REG1(12 downto 10),-- Address 27
                                OUT_S_REG1(9 downto 5),
                                OUT_S_REG1(4 downto 0),
                                "00" & OUT_S_REG2(12 downto 10),-- Address 30
                                OUT_S_REG2(9 downto 5),
                                OUT_S_REG2(4 downto 0),
                                "00" & OUT_S_MEM2(12 downto 10),-- Address 33 
                                OUT_S_MEM2(9 downto 5),
                                OUT_S_MEM2(4 downto 0),
                                "00" & OUT_L_MEM1(12 downto 10),-- Address 36
                                OUT_L_MEM1(9 downto 5),
                                OUT_L_MEM1(4 downto 0),
                                "00" & OUT_L_MEM2(12 downto 10),-- Address 39
                                OUT_L_MEM2(9 downto 5),
                                OUT_L_MEM2(4 downto 0),
                                "00" & OUT_ADD(12 downto 10),   -- Address 42
                                OUT_ADD(9 downto 5),
                                OUT_ADD(4 downto 0),
                                "00" & OUT_SUB(12 downto 10),   -- Address 45
                                OUT_SUB(9 downto 5),
                                OUT_SUB(4 downto 0),
                                "00" & OUT_AND(12 downto 10),   -- Address 48
                                OUT_AND(9 downto 5),
                                OUT_AND(4 downto 0),
                                "00" & OUT_OR(12 downto 10),    -- Address 51
                                OUT_OR(9 downto 5),
                                OUT_OR(4 downto 0),
                                "00" & OUT_NOP(12 downto 10),   -- Address 54
                                OUT_NOP(9 downto 5),
                                OUT_NOP(4 downto 0),
                                others => "00000");

  component ring_shifter
    port( CLK,RESET : in std_logic;
          Q         : inout std_logic_vector(2 downto 0));
  end component;

  component mux2to1 
    generic (N : integer);
    port (IN0,IN1 : in std_logic_vector (N-1 downto 0); --input signals
          SEL: in std_logic; --select signal
          MUX_OUT : out std_logic_vector (N-1 downto 0));--N bits output
  end component;

  component reg_n
    GENERIC 	( N : INTEGER := 6 );
    PORT		( A : in std_logic_vector (N-1 downto 0);
                          Q : out std_logic_vector (N-1 downto 0);
                          CLK	: in Std_logic;
                          RST_n	: In std_logic );
  end component;

  signal ext_addr_sel : std_logic;  -- Selection of EXTERNAL address (OPCODE or FUNC)
  signal ext_addr, mem_addr, mem_addr_incremented, mem_addr_ff : std_logic_vector(5 downto 0);
  signal mem_mux_out : mux_out_array;
  signal zeros_4, mem_out : std_logic_vector(4 downto 0);
  signal ring_out: std_logic_vector(2 downto 0);
  
begin

  zeros_4 <= (others=>'0');

  -- ADDRESS SELECTOR
  -- OPCODE and FUNC values into "myTypes" files are changed in order to use them to
  -- directly access the first cell memory of each command
  -- IF OPCODE = "111111" => RTYPE FUNCTION identified by FUNC

  ext_addr_sel <= '1' when (OPCODE = (OPCODE'range=>'1')) else '0';

  Ext_mux: mux2to1 generic map ( N => 6 ) port map
    ( IN0 => OPCODE,
      IN1 => FUNC(5 downto 0),
      SEL => ext_addr_sel,
      MUX_OUT => ext_addr );

  

  -- INCREMENTER
  -- In order to access the cells associated to the second and the third stage,
  -- the address selected from outside should be incremented two times.

  mem_addr_incremented <= std_logic_vector(unsigned(mem_addr) + 1);

  -- MEMORY ADDRESS SELECTOR
  Mem_mux: mux2to1 generic map ( N => 6 ) port map
    ( IN0 => mem_addr_incremented,
      IN1 => ext_addr,
      SEL => ring_out(2),
      MUX_OUT => mem_addr_ff );

  Reg: reg_n generic map ( N => 6 ) port map
    ( A => mem_addr_ff,
      Q => mem_addr,
      CLK => Clk,
      RST_n => Rst );

  

  -- 3-bit RING SHIFTER
  -- Only one bit is set to 1 and always shifts.
  -- At each clock cycle:
  -- RESET:     Q = "100"
  --            Q = "001"
  --            Q = "010"
  --            Q = "100"
  --            ...and so on.
  -- Used to select:
  -- . Which output stage should be activated
  -- . Address to send to the memory

  Ring: ring_shifter port map
    ( CLK => Clk,
      RESET => Rst,
      Q => ring_out );

  -- MUX OUTPUT
  -- The ring shifter selects which one will be activated at each time. The
  -- remaining outputs will be set to zero.

  mem_out <= OUT_MEM(to_integer(unsigned(mem_addr)));
  
  Mux_out: for i in 0 to 2 generate
    Mux_out_i: mux2to1 generic map(N => 5) port map
      ( IN0 => zeros_4,
        IN1 => mem_out,
        SEL => ring_out(i),
        MUX_OUT => mem_mux_out(i) ); 
  end generate;

  --OUTPUT CONNECTION
  EN1   <= mem_mux_out(0)(2) ; 
  RF1   <= mem_mux_out(0)(1) ; 
  RF2   <= mem_mux_out(0)(0) ; 
  EN2   <= mem_mux_out(1)(4) ; 
  S1    <= mem_mux_out(1)(3) ; 
  S2    <= mem_mux_out(1)(2) ; 
  ALU1  <= mem_mux_out(1)(1) ; 
  ALU2  <= mem_mux_out(1)(0) ; 
  EN3   <= mem_mux_out(2)(4) ; 
  RM    <= mem_mux_out(2)(3) ; 
  WM    <= mem_mux_out(2)(2) ; 
  S3    <= mem_mux_out(2)(1) ; 
  WF1   <= mem_mux_out(2)(0) ;
    
end STRUCTURE;
  


  
